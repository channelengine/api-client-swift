//
// MerchantOrderLineResponse.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



open class MerchantOrderLineResponse: Codable {

    public enum Status: String, Codable { 
        case inProgress = "IN_PROGRESS"
        case shipped = "SHIPPED"
        case inBackorder = "IN_BACKORDER"
        case canceled = "CANCELED"
        case manco = "MANCO"
        case inCombi = "IN_COMBI"
        case closed = "CLOSED"
        case new = "NEW"
        case returned = "RETURNED"
        case requiresCorrection = "REQUIRES_CORRECTION"
    }
    public enum Condition: String, Codable { 
        case new = "NEW"
        case newRefurbished = "NEW_REFURBISHED"
        case usedAsNew = "USED_AS_NEW"
        case usedGood = "USED_GOOD"
        case usedReasonable = "USED_REASONABLE"
        case usedMediocre = "USED_MEDIOCRE"
        case unknown = "UNKNOWN"
    }
    public var status: Status?
    public var isFulfillmentByMarketplace: Bool?
    public var merchantProductNo: String?
    public var channelProductNo: String
    public var quantity: Int
    /** The value of a single unit of the ordered product including VAT  (in the tenant&#39;s base currency calculated using the exchange rate at the time of ordering). */
    public var unitPriceInclVat: Double
    /** A fixed fee that is charged by the Channel for this orderline.  This field is optional, send 0 if not applicable. */
    public var feeFixed: Double?
    /** A percentage fee that is charged by the Channel for this orderline.  This field is optional, send 0 if not applicable. */
    public var feeRate: Double?
    /** The condition of the product, this can be used to indicate that a product is a second-hand product */
    public var condition: Condition?


    
    public init(status: Status?, isFulfillmentByMarketplace: Bool?, merchantProductNo: String?, channelProductNo: String, quantity: Int, unitPriceInclVat: Double, feeFixed: Double?, feeRate: Double?, condition: Condition?) {
        self.status = status
        self.isFulfillmentByMarketplace = isFulfillmentByMarketplace
        self.merchantProductNo = merchantProductNo
        self.channelProductNo = channelProductNo
        self.quantity = quantity
        self.unitPriceInclVat = unitPriceInclVat
        self.feeFixed = feeFixed
        self.feeRate = feeRate
        self.condition = condition
    }
    

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {

        var container = encoder.container(keyedBy: String.self)

        try container.encodeIfPresent(status, forKey: "Status")
        try container.encodeIfPresent(isFulfillmentByMarketplace, forKey: "IsFulfillmentByMarketplace")
        try container.encodeIfPresent(merchantProductNo, forKey: "MerchantProductNo")
        try container.encode(channelProductNo, forKey: "ChannelProductNo")
        try container.encode(quantity, forKey: "Quantity")
        try container.encode(unitPriceInclVat, forKey: "UnitPriceInclVat")
        try container.encodeIfPresent(feeFixed, forKey: "FeeFixed")
        try container.encodeIfPresent(feeRate, forKey: "FeeRate")
        try container.encodeIfPresent(condition, forKey: "Condition")
    }

    // Decodable protocol methods

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)

        status = try container.decodeIfPresent(Status.self, forKey: "Status")
        isFulfillmentByMarketplace = try container.decodeIfPresent(Bool.self, forKey: "IsFulfillmentByMarketplace")
        merchantProductNo = try container.decodeIfPresent(String.self, forKey: "MerchantProductNo")
        channelProductNo = try container.decode(String.self, forKey: "ChannelProductNo")
        quantity = try container.decode(Int.self, forKey: "Quantity")
        unitPriceInclVat = try container.decode(Double.self, forKey: "UnitPriceInclVat")
        feeFixed = try container.decodeIfPresent(Double.self, forKey: "FeeFixed")
        feeRate = try container.decodeIfPresent(Double.self, forKey: "FeeRate")
        condition = try container.decodeIfPresent(Condition.self, forKey: "Condition")
    }
}

