//
// ChannelOrderLineRequest.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation



open class ChannelOrderLineRequest: Codable {

    public enum Condition: String, Codable { 
        case new = "NEW"
        case newRefurbished = "NEW_REFURBISHED"
        case usedAsNew = "USED_AS_NEW"
        case usedGood = "USED_GOOD"
        case usedReasonable = "USED_REASONABLE"
        case usedMediocre = "USED_MEDIOCRE"
        case unknown = "UNKNOWN"
    }
    public var channelProductNo: String
    public var quantity: Int
    /** The value of a single unit of the ordered product including VAT  (in the tenant&#39;s base currency calculated using the exchange rate at the time of ordering). */
    public var unitPriceInclVat: Double
    /** A fixed fee that is charged by the Channel for this orderline.  This field is optional, send 0 if not applicable. */
    public var feeFixed: Double?
    /** A percentage fee that is charged by the Channel for this orderline.  This field is optional, send 0 if not applicable. */
    public var feeRate: Double?
    /** The condition of the product, this can be used to indicate that a product is a second-hand product */
    public var condition: Condition?


    
    public init(channelProductNo: String, quantity: Int, unitPriceInclVat: Double, feeFixed: Double?, feeRate: Double?, condition: Condition?) {
        self.channelProductNo = channelProductNo
        self.quantity = quantity
        self.unitPriceInclVat = unitPriceInclVat
        self.feeFixed = feeFixed
        self.feeRate = feeRate
        self.condition = condition
    }
    

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {

        var container = encoder.container(keyedBy: String.self)

        try container.encode(channelProductNo, forKey: "ChannelProductNo")
        try container.encode(quantity, forKey: "Quantity")
        try container.encode(unitPriceInclVat, forKey: "UnitPriceInclVat")
        try container.encodeIfPresent(feeFixed, forKey: "FeeFixed")
        try container.encodeIfPresent(feeRate, forKey: "FeeRate")
        try container.encodeIfPresent(condition, forKey: "Condition")
    }

    // Decodable protocol methods

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: String.self)

        channelProductNo = try container.decode(String.self, forKey: "ChannelProductNo")
        quantity = try container.decode(Int.self, forKey: "Quantity")
        unitPriceInclVat = try container.decode(Double.self, forKey: "UnitPriceInclVat")
        feeFixed = try container.decodeIfPresent(Double.self, forKey: "FeeFixed")
        feeRate = try container.decodeIfPresent(Double.self, forKey: "FeeRate")
        condition = try container.decodeIfPresent(Condition.self, forKey: "Condition")
    }
}

